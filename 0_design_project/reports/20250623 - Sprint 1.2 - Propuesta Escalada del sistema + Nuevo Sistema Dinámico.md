
# **Plan de Implementación: Integración del Sistema "Water Tank"**

Este plan está diseñado para integrar un nuevo sistema dinámico de tanque de agua y refactorizar componentes clave para mantener la agnosticidad del framework, siguiendo una secuencia lógica y minimizando el riesgo.

---

#### **Paso 1: Crear el Componente de Sistema Dinámico Base (WaterTankSystem)**

El primer paso es crear el "corazón" del nuevo sistema: el modelo matemático que define su comportamiento. Este componente es autocontenido y no tiene dependencias con el resto del orquestador de simulación.

*   **Sub-pasos:**
    1.  **Crear el archivo `components/systems/water_tank_system_v1_OneValveControl.py`:**
        *   La clase `WaterTankSystem` implementará la interfaz `DynamicSystem`.
        *   El constructor `__init__` recibirá los parámetros físicos del tanque: área (`area_m2`), coeficiente de la válvula de salida (`outflow_coeff`), y gravedad (`g`).
        *   El vector de estado será de una dimensión: `[level_m]`.
        *   El método `_dynamics` implementará la ecuación diferencial: `dh/dt = (Qin - Qout) / A`
        *   El método `apply_action` usará `scipy.integrate.odeint` para resolver la dinámica en un paso de tiempo `dt`, similar a `InvertedPendulumSystem`.
        *   El método `reset` simplemente devolverá el estado inicial proporcionado.
    2.  **Modificar archivos de configuración `config.yaml` y `sub_config_data_save.yaml`:**
        * Se cambiará `type` a `water_tank`. 
        * Se definirán los nuevos `params`: `area_m2`, `outflow_coeff` y `g`.
        * Definir los nuevos criterios de terminación: `level_limit_m`, y los umbrales de estabilización
        * Ajustar el `setpoint` del controlador al nivel de agua deseado.
        * Modificar la sección `environment.system` en el `config.yaml` y las variables de estado y recompensa correspondientes al nuevo sistema.
        * Modificar los parámetros correspondientes en el `sub_config_data_save.yaml`

*   **Implicancias y Dependencias:**
    *   **Nuevos Archivos:** `components/systems/water_tank_system_v1_OneValveControl.py`
    *   **Interfaces:** Utiliza `interfaces/dynamic_system.py` sin modificarla.
    *   **Impacto:** Cero impacto en el resto del sistema en este punto. Es una adición aislada. A excepción de los archivos de config `YAML`.

---

#### **Paso 2: Crear el Orquestador del Entorno (WaterTankEnvironment)**

Con el sistema dinámico definido, ahora creamos el entorno que lo conecta con el controlador, el agente y las reglas de la simulación (terminación, recompensas).

*   **Sub-pasos:**
    1.  **Crear el archivo `components/environments/water_tank_environment.py`:**
        *   La clase `WaterTankEnvironment` implementará la interfaz `Environment`.
        *   Su constructor `__init__` será muy similar al de `PendulumEnvironment`, inyectando `system`, `controller`, `agent`, `reward_function`, `stability_calculator` y `config`.
        *   Leerá desde la `config` los parámetros específicos del entorno del tanque: límites de nivel (`level_limit_m`), umbrales de estabilización (`level_threshold`), etc.
        *   El método `step` orquestará la llamada a `controller.compute_action`, `system.apply_action`, `reward_function.calculate` y `stability_calculator.calculate_instantaneous_stability`.
        *   El método `check_termination` evaluará si el nivel del agua excede los límites o si se ha alcanzado el objetivo de estabilización.
        *   El método `reset` orquestará el reseteo de las variables y resto de componentes (`system`, `controller`, `agent`).

*   **Implicancias y Dependencias:**
    *   **Nuevos Archivos:** `components/environments/water_tank_environment.py`.
    *   **Interfaces:** Utiliza `interfaces/environment.py` sin modificarla.
    *   **Impacto:** Aún no está integrado en el `DIContainer`. Sigue siendo una adición aislada funcionalmente.

---

#### **Paso 3: Refactorización Integral de `SimulationManager` y `ExtendedMetricsCollector` para un Logging Agnóstico pero Centralizado**

El objetivo es implementar un sistema de logging donde ExtendedMetricsCollector es el componente inteligente que sabe qué datos extraer y cuándo, basándose en la configuración. SimulationManager será un orquestador puro que simplemente invoca los métodos de evento del colector en los momentos apropiados del ciclo de vida de la simulación, pasándoles las instancias de los componentes como contexto.

- **Sub-pasos:**
    1. **Requerimientos para sub_config_data_save.yaml**
        - **Objetivo:** Adaptar la configuración para que declare explícitamente la frecuencia de registro de cada métrica, guiando así al ExtendedMetricsCollector.
        - **Requerimientos de Implementación:**
            1. **Estructurar por Frecuencia:** La sección json_history será reestructurada. En lugar de una lista plana de métricas (json_history_params), contendrá una subsección llamada logging_frequency.
            2. **Definir Claves de Frecuencia:** Dentro de logging_frequency, se definirán dos claves:
                - on_step: Contendrá una lista de nombres de métricas que deben registrarse en cada paso de simulación dt (alta frecuencia).
                - on_decision_interval: Contendrá una lista de nombres de métricas que deben registrarse una vez por intervalo de decisión del agente (baja frecuencia).
            3. **Migrar Métricas:** Las métricas existentes en el archivo sub_config_data_save.yaml serán redistribuidas bajo estas dos nuevas claves según corresponda (ej. pendulum_angle en on_step; td_error_kp en on_decision_interval).
            4. **Mantener Compatibilidad de Salida:** Esta reestructuración es solo para la configuración de entrada. El formato del archivo JSON de salida (simulation_data...json) no cambiará; seguirá siendo un diccionario de listas de métricas, asegurando la compatibilidad con el post-procesamiento existente.
    2. **Requerimientos para interfaces/metrics_collector.py**
        - **Objetivo:** Actualizar la interfaz para que refleje los métodos de logging basados en eventos que SimulationManager invocará.
        - **Requerimientos de Implementación:**
            1. **Eliminar log Genérico:** El método abstracto log(metric_name: str, metric_value: Any) será **eliminado** de la interfaz.
            2. **Añadir Métodos de Evento:** Se **añadirán** los siguientes métodos abstractos, que recibirán como argumentos las instancias de los componentes de simulación para poder extraer datos de ellos:
                - log_initial_state(env: Environment, ctrl: Controller, agent: RLAgent): Para registrar el estado inicial del episodio.
                - log_on_step(env: Environment, ctrl: Controller, agent: RLAgent): Para registrar métricas de alta frecuencia en cada paso dt.
                - log_on_decision_interval(env: Environment, ctrl: Controller, agent: RLAgent, interval_data: Dict): Para registrar métricas de baja frecuencia. El interval_data será un diccionario que contendrá información calculada durante el intervalo, como la recompensa total del intervalo o la duración del cálculo de learn.
                - log_on_episode_end(summary_data: Dict): Para registrar métricas que solo se conocen al final del episodio.
    3. **Requerimientos para components/analysis/extended_metrics_collector.py**
        - **Objetivo:** Convertir esta clase en el componente central e inteligente del logging.
        - **Requerimientos de Implementación:**
            1. **Nuevo Constructor Inteligente:** El __init__ se modificará para aceptar solo logging_directives: Dict.
                - Dentro del constructor, leerá la nueva estructura logging_frequency de las directivas.
                - **Construirá internamente los "mapas de extracción"**: uno para on_step y otro para on_decision_interval. Cada mapa asociará un nombre de métrica (ej. 'pendulum_angle') a una función lambda que define cómo extraer ese valor de una instancia de Environment, Controller o Agent que se recibirá como argumento en los métodos de log.
            2. **Implementar log_initial_state:**
                - Este método aceptará (env, ctrl, agent) como argumentos.
                - Utilizará sus mapas de extracción para obtener y registrar los valores iniciales de todas las métricas configuradas (tanto de on_step como de on_decision_interval, con valores por defecto o iniciales para las segundas).
            3. **Implementar log_on_step:**
                - Aceptará (env, ctrl, agent).
                - Iterará **únicamente** sobre su mapa de extracción on_step.
                - Para cada métrica, ejecutará la función de extracción correspondiente pasándole el componente adecuado (env, ctrl, agent) y almacenará el resultado.
            4. **Implementar log_on_decision_interval:**
                - Aceptará (env, ctrl, agent, interval_data).
                - Iterará **únicamente** sobre su mapa de extracción on_decision_interval.
                - Extraerá y almacenará los valores, utilizando tanto los componentes como el diccionario interval_data si es necesario.
            5. **Implementar log_on_episode_end:**
                - Aceptará el summary_data del episodio.
                - Extraerá métricas finales como termination_reason y las añadirá a sus datos recolectados, replicando el valor en todas las filas para mantener la consistencia del DataFrame.
    4. **Requerimientos para simulation_manager.py**
        - **Objetivo:** Simplificar drásticamente SimulationManager para que solo orqueste eventos, sin tener conocimiento alguno sobre los nombres o la lógica de extracción de las métricas.
        - **Requerimientos de Implementación:**
            1. **Inicialización Única y Completa en __init__:**
                - El método _resolve_dependencies se mantendrá para resolver las instancias principales de los componentes (env, agent, ctrl, etc.) una sola vez en el init de la clase
			2. **Centralización de la Lógica de Terminación:**
				- Se creará un nuevo método privado, _check_episode_termination(env: Environment) -> Tuple[bool, str].
				- Este método encapsulará toda la lógica para determinar si un episodio debe terminar, absorbiendo la lógica de env.check_termination() que evalúa los límites excedidos, meta alcanzada, y a su vez los de agent.should_episode_terminate_early() que evalúa el término anticipado, y combinado con la comprobación del tiempo máximo de episodio.
				- Devolverá una tupla con un booleano (True si debe terminar) y un string con la razón ('limit_exceeded', 'goal_reached', 'agent_requested_early_termination' o 'time_limit').
				- Los métodos que lo requieran como el bucle de _run_episode llamará a este método en lugar de tener la lógica de terminación dispersa.
			3. **Eliminación Completa de Lógica de Logging:** Se **eliminarán** todos los métodos privados de logging (_log_step_metrics, _log_initial_metrics, _log_decision_boundary_metrics). El SimulationManager no contendrá ninguna cadena de texto con nombres de métricas.
			4. **Modificar _run_episode:**
				- Al inicio, después de env.reset(), se añadirá la llamada: metrics_collector.log_initial_state(env, ctrl, agent).
				- En el bucle de decisión, después de agent.learn(), se creará un pequeño diccionario interval_data con información del intervalo (ej. {'learn_duration_ms': ...}) y se llamará a: metrics_collector.log_on_decision_interval(env, ctrl, agent, interval_data).
				- Al final, después de generar el resumen del episodio, se llamará a: metrics_collector.log_on_episode_end(episode_summary_dict).
			5. **Modificar _run_standard_interval_steps:**
				- Dentro de su bucle for step_idx in range(num_steps_this_interval), justo después de la llamada a env.step(), se añadirá la llamada: metrics_collector.log_on_step(env, ctrl, agent).

- **Resultado Final del Paso:**
    - SimulationManager es ahora un orquestador puro y completamente agnóstico al contenido que se loguea. Su código es genérico y válido para cualquier sistema.
    - ExtendedMetricsCollector se convierte en un componente autocontenido e inteligente, cuya lógica es dictada enteramente por la configuración, cumpliendo el principio de "configuración declarativa".
    - La separación de responsabilidades es máxima y clara, adhiriéndose a los principios de diseño más estrictos.

---

#### **Paso 4: Automatizar el Registro de Componentes en el `DIContainer`**

Eliminar cualquier registro manual o descubrimiento "mágico" de componentes. El DIContainer se modificará para que la selección de la clase concreta para System, Environment, Controller y Agent sea determinada explícitamente por parámetros en el config.yaml, haciendo el sistema más robusto y transparente.

- **Acciones Requeridas:**
    1. **Ampliar la Configuración en config.yaml:**
        - Para cada una de las secciones de componentes principales (system, environment, controller, agent), se añadirá un nuevo par de claves obligatorias:
            - module_path: Una cadena que especifica la ruta del módulo Python donde se encuentra la clase (ej. components.systems.water_tank_system).
            - class_name: Una cadena con el nombre exacto de la clase a instanciar (ej. WaterTankSystem).
        - El archivo config.yaml (para el péndulo) y el nuevo config_tank.yaml (para el tanque) se actualizarán para incluir estas dos nuevas claves en cada una de las cuatro secciones mencionadas.
    2. **Refactorizar el DIContainer (di_container.py):**
        - **Eliminar Importaciones Estáticas:** Se removerán todas las declaraciones import al inicio del archivo que traen clases concretas como PIDQLearningAgent, InvertedPendulumSystem, etc.
        - **Modificar el Proceso de Registro en build_container:**
            - La función build_container ahora leerá las nuevas claves module_path y class_name desde el main_config para cada componente.
            - Utilizará la biblioteca importlib de Python para importar dinámicamente el módulo especificado en module_path.
            - Una vez importado el módulo, obtendrá el objeto de la clase usando su nombre desde class_name.
            - Con la clase ya cargada dinámicamente, la pasará al método register_..._type de la factoría correspondiente (SystemFactory, AgentFactory, etc.), usando el type de la configuración como clave de registro.
        - El resto de la lógica de build_container, que resuelve las dependencias y las pasa a los constructores, no necesita cambios, ya que se basa en las interfaces y los type que ya se manejan correctamente.
            
- **Resultado Final del Paso:**
    - La selección de componentes es 100% explícita y controlada por la configuración, eliminando cualquier ambigüedad o dependencia de la estructura de archivos.
    - Para integrar un componente completamente nuevo, un desarrollador solo necesita crear su clase y luego especificar su module_path y class_name en el archivo YAML, sin tocar el código del DIContainer.
    - El DIContainer se vuelve verdaderamente agnóstico a las implementaciones, ya que su código no contiene ninguna referencia a nombres de clases concretas.

